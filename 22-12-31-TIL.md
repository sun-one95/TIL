### 동기적과 비동기적

작업을 동기적으로 처리한다면, 앞에 순서의 작업이 처리가 완료가 된 후에 다음 작업으로 넘어 갈 수 있다.

이렇게 작업을 진행하게 되면 선 작업이 완료되기 전까지 다른 작업을 못하기 때문에 불편하고 시간도 오래걸린다.

하지만 비동기적은 동시에 작업을 진행하기 때문에 다른 작업이 가능하며, 시간도 빠르다.



```react
function work() {
  const start = Date.now()
  for (let i = 0; i < 1000000000; i++) {}
  const end = Date.now()
  console.log(end - start + 'ms')
}

work();
console.log('다음 작업');

// 출력 순서
517ms
다음 작업
```



위 코드는 따로 어떤 비동기 작업을 하지않은 상태이다. 그러므로 ``work()`` 함수가 실행이 완료된뒤에야 ``다음 작업``이 출력 될수 있다.

만약 비동기적으로 작동하게 하고 싶다면, ``setTimeout()`` 이라는 함수를 사용해줘야 한다.

```react
function work() {
  setTimeout(() => {
    const start = Date.now()
    for (let i = 0; i < 1000000000; i++) {}
    const end = Date.now()
    console.log(end - start + 'ms')
  }, 0)
}

console.log('작업 시작');
work();
console.log('다음 작업');

// 출력 순서
작업 시작
다음 작업
508ms
```



``setTimeout``이라는 함수는 첫번째 파라미너에 넣는 함수를 두번째 파라미터에 넣은 시간(ms 단위)이 흐른 후 호출해 준다.

그런데, 만약에 work 함수가 끝난 다음에 어떤 작업을 처리하고 싶다면 어떻게 해야 할까?

이때는, 콜백 함수를 파라미터로 전달해주면 된다. **콜백 함수란, 함수 타입의 값을 파라미터로 넘겨줘서, 파라미터로 받은 함수를 특정 작업이 끝나면 호출해주는 것**을 의미한다.



```react
function work(callback) {
  setTimeout(() => {
    const start = Date.now()
    for (let i = 0; i < 1000000000; i++) {}
    const end = Date.now()
    console.log(end - start + 'ms')
    callback()
  }, 0)
}

console.log('작업 시작');
work(() => {
  console.log('작업이 끝났어요!')
});
console.log('다음 작업');
```

다음과 같은 작업들은 주로 비동기적으로 처리하게 된다.

- Ajax Web API 요청: 만약 서버쪽에서 데이터를 받아와야 할 때는, 요청을 하고 서버에 응답을 할 때 까지 대기를 해야 되기 때문에 작업을 비동기적으로 처리한다.
- 파일 읽기: 주로 서버 쪽에서 파일을 읽어야 하는 상황에는 비동기적으로 처리한다.
- 암호화/복호화: 암호화/복호화를 할 때에도 바로 처리가 되지 않고, 시간이 어느정도 걸리는 경우가 있기 때문에 비동기적으로 처리한다.
- 작업예약: 단순히 어떤 작업을 몇초 후에 스케줄링 해야 하는 상황에는, setTimeout을 사용하여 비동기적으로 처리한다



### Promise

프로미스는 비동기 작업을 보다 쉽고 편하게 사용하기 위해 ES6에 도입된 기능이다. 이전에는 비동기 작업을 처리 할 때에

 콜백 함수로 처리를 해왔다. 하지만, 콜백 함수로 처리를 하게 된다면 비동기 작업이 많아질 경우 코드가 쉽게 난잡해지게 된다.

(콜백 지옥)

비동기적으로 처리해야 하는 일이 많아질수록, 코드의 깊이가 계속 깊어지는 현상이 있는데, Promise를 사용하면 이렇게 코드의 깊이가 깊어지는 현상을 방지 할 수 있다.

Promise는 다음과 같이 만든다.

```react
const myPromise = new Promise((resolve, reject) => {
  // 구현..
})
```



Promise는 성공 할 수도 있고, 실패 할 수 도 있다. 성골할 때는 ``resolve`` 를 호출해주면 되고, 실패할 때에는

```reject``` 를 호출해주면 된다.

```react
const myPromise = new Promise((resolve, reject) => {
	setTimeout(() => {
    resolve(1)
  }, 1000)  
})

myPromise.then(n => {
  console.log(n)
})
```

resolve를 호출 할 때 특정 값을 파라미터로 넣어주면, 이 값을 작업이 끝나고 나서 사용할 수 있다.

작업이 끝나고 나서 또 다른 작업을 해야 할 때에는 Promise 뒤에, ``.then(...)`` 을 붙여서 사용하면 된다.



1초뒤에 실패되게끔 작성

```react
const myPromise = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject(new Error())
  }, 1000)
})

myPromise
  .then(n => {
  	console.log(n)
	})
	.catch(error => {
  console.log(error)
})
```

실패하는 상황에서는 ``reject`` 를 사용하고, ``.catch``를 통하여 실패했을시 수행 할 작업을 설정 할 수 있다.

이제, Promise를 만드는 함수를 작성해 보자

```react
function increaseAndPrint(n) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const value = n + 1;
      if (value === 5) {
        const error = new Error();
        error.name = 'ValueIsFiveError';
        reject(error);
        return;
      }
      console.log(value);
      resolve(value);
    }, 1000);
  });
}

increaseAndPrint(0).then((n) => {
  console.log('result: ', n);
})
```

















